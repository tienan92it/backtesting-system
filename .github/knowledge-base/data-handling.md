# Data Handling (Binance and Beyond)

**Data Sources**: Initially, the system will support **Binance** as the source of historical crypto market data (e.g. price candles for BTC/USDT, ETH/USDT, etc.). Binance is one of the largest exchanges and provides a comprehensive API for historical **OHLCV** (Open-High-Low-Close-Volume) data. We plan to fetch candlestick data at various intervals (1min, 5min, 1h, 1d, etc.) as needed for different strategies.

**Fetching Historical Data**: Binance’s public REST API has an endpoint for klines (candles). For example, the `/api/v3/klines` endpoint returns candlesticks given a symbol, interval, and time range. We can use the **python-binance** library’s wrapper: `Client.get_historical_klines(symbol, interval, start_time, end_time)`. This function handles looping over multiple API calls to fetch large date ranges. (By default, Binance API returns max 500 or 1000 candles per request ([Save Historical data from Binance - Crypto Exchange Python Programming Blog](https://sammchardy.github.io/historical-data-download-binance/#:~:text=We%20note%20from%20this%20that,over%20a%20long%20time%20period)), so the library’s internal loop or our own loop is needed for long histories). **Rate limiting** should be respected (Binance limits requests weight per minute), so implement pauses if fetching very large datasets.

If not using python-binance, we can directly use requests/CCXT. For instance, CCXT’s `fetch_ohlcv(symbol, timeframe, since, limit)` can get historical OHLCV and is already set up for Binance. The advantage of CCXT is that adding support for another exchange later (say Coinbase or Kraken) would just require a different exchange instance but the same function call, as CCXT provides a unified API ([CCXT Python: Exploring Cryptocurrency Trading on Binance, Kucoin, and Bitmex | by Manaan Ansari | AWS Tip](https://awstip.com/ccxt-python-exploring-cryptocurrency-trading-on-binance-kucoin-and-bitmex-b2bae06ce79c#:~:text=CCXT%20is%20a%20popular%20open,to%20build%20cryptocurrency%20trading%20applications)). To keep the design extensible, it might be wise to use CCXT from the start for data retrieval, but ensure to handle any data formatting to our system’s standard.

**Data Cleaning**: Once data is fetched (likely in JSON or list format), convert it into a Pandas DataFrame for easy use. Typical cleaning steps:

- **Column naming**: Label the columns as `['open_time', 'open', 'high', 'low', 'close', 'volume', ...]` based on Binance’s output. (Binance returns an array of values per candle ([Save Historical data from Binance - Crypto Exchange Python Programming Blog](https://sammchardy.github.io/historical-data-download-binance/#:~:text=The%20get_klines%20endpoint%20returns%20an,of%20klines%20in%20this%20order)), where index 0 is open time, 1 open price, ..., 5 volume, etc. We will name and cast these appropriately).
- **Type conversion**: Convert numeric fields from strings to floats. Convert timestamps (in milliseconds) to Python datetime for indexing. Pandas can handle this with `pd.to_datetime(df['open_time'], unit='ms')`.
- **Indexing**: Set the datetime as the DataFrame index (or at least ensure data is sorted by time). This makes time-based slicing and joining easier. Make sure there are no duplicate timestamps; if found, drop duplicates or aggregate as needed.
- **Missing data**: Check for gaps or missing intervals. If Binance data has missing minutes (due to no trades, etc.), decide how to handle it: either fill with the last price or remove those intervals. For backtesting, consistent time steps are important. Binance typically provides continuous candles even if volume is zero, but it's good to verify.
- **Storage**: For repeated backtests, it’s useful to cache data locally. The system can save the fetched DataFrame to a CSV file or a small **SQL database** (like SQLite) with a schema for symbol and timeframe. This way, if the same data range is requested again, the system can load from disk instead of calling the API again. A simple caching mechanism (e.g., check if `data/BTCUSDT_1h_2020-2022.csv` exists) can speed up development and conserve API calls. Ensure the user can refresh data if needed (e.g., a `-refresh` flag to refetch from API).

**Data Example**: For instance, fetching 1-hour BTC/USDT data for 2021 might yield a CSV or DataFrame with columns: time, open, high, low, close, volume. The backtester will use this DataFrame as the input price series for the strategy simulation.

**Extending Data Sources**: While Binance is the first target, the data module should be designed to add other exchanges easily. A **DataFetcher interface** can abstract the fetching logic. For Binance, one implementation uses Binance API; for another exchange, implement the same interface using that exchange’s API or CCXT. The rest of the system would use a standardized format (DataFrame) regardless of source. This abstraction layer will make it simple to plug in Coinbase, Kraken, etc. in the future. Many exchanges have similar OHLCV endpoints, so the key differences will be authentication (if needed for certain data), rate limits, and data field naming—abstracting those in one place will localize any changes needed for new sources.

**Best Practices & Challenges**: A key challenge is ensuring data integrity and alignment. Always verify that the data’s timestamp ordering is correct and there are no future data leaks (e.g., if using minute data, ensure the strategy at 10:00 only sees data up to 09:59 candle close). Also, consider time zones: Binance timestamps are in UTC. If users are in different time zones, it shouldn’t affect the backtest since we’ll use timezone-aware UTC times or naive times consistently. Document the data loading process so users know what data they can get by default and how to plug in their own data (perhaps a user might have custom CSV they want to test, so allow loading from CSV as an option).